From a53b90729aece7415ecd92512eae45c775ea355b Mon Sep 17 00:00:00 2001
From: Mickael Guene <mickael.guene@st.com>
Date: Thu, 3 Dec 2015 07:59:09 +0100
Subject: [PATCH]  Add support for SHF_ARM_NOREAD section flag

 Catch section by name with .text.noread* pattern and apply
SHF_ARM_NOREAD section flag attribute to them.
 Only set PF_X attribute for segment if all sections in segment have
SHF_ARM_NOREAD flag.
 Support SHF_ARM_NOREAD string in INPUT_SECTION_FLAGS ld scripts.
---
 bfd/elf32-arm.c   | 57 +++++++++++++++++++++++++++++++++++++++++++++++++++++++
 include/elf/arm.h |  1 +
 2 files changed, 58 insertions(+)

diff --git a/bfd/elf32-arm.c b/bfd/elf32-arm.c
index 9fd5720..774d086 100644
--- a/bfd/elf32-arm.c
+++ b/bfd/elf32-arm.c
@@ -14691,6 +14691,7 @@ elf32_arm_post_process_headers (bfd * abfd, struct bfd_link_info * link_info ATT
 {
   Elf_Internal_Ehdr * i_ehdrp;	/* ELF file header, internal form.  */
   struct elf32_arm_link_hash_table *globals;
+  struct elf_segment_map *m;
 
   i_ehdrp = elf_elfheader (abfd);
 
@@ -14716,6 +14717,26 @@ elf32_arm_post_process_headers (bfd * abfd, struct bfd_link_info * link_info ATT
       else
 	i_ehdrp->e_flags |= EF_ARM_ABI_FLOAT_SOFT;
     }
+
+  /* Scan segment to set p_flags attribute if it contains only sections with
+     SHF_ARM_NOREAD flag.  */
+  for (m = elf_seg_map (abfd); m != NULL; m = m->next)
+    {
+      unsigned int j;
+
+      if (m->count == 0)
+	continue;
+      for (j = 0; j < m->count; j++)
+	{
+	  if (!(elf_section_flags (m->sections[j]) & SHF_ARM_NOREAD))
+	    break;
+	}
+      if (j == m->count)
+	{
+	  m->p_flags = PF_X;
+	  m->p_flags_valid = 1;
+	}
+    }
 }
 
 static enum elf_reloc_type_class
@@ -14767,6 +14788,10 @@ elf32_arm_fake_sections (bfd * abfd, Elf_Internal_Shdr * hdr, asection * sec)
       hdr->sh_type = SHT_ARM_EXIDX;
       hdr->sh_flags |= SHF_LINK_ORDER;
     }
+
+  if (sec->flags & SEC_COFF_NOREAD)
+    hdr->sh_flags |= SHF_ARM_NOREAD;
+
   return TRUE;
 }
 
@@ -16135,6 +16160,31 @@ elf32_arm_get_synthetic_symtab (bfd *abfd,
   return n;
 }
 
+static const struct bfd_elf_special_section
+elf32_arm_special_sections[] =
+{
+  { STRING_COMMA_LEN (".text.noread"),  -2, SHT_PROGBITS,
+    SHF_ALLOC + SHF_EXECINSTR + SHF_ARM_NOREAD },
+  { NULL,			      0, 0, 0,			0 }
+};
+
+static bfd_boolean
+arm_elf_section_flags (flagword * flags, const Elf_Internal_Shdr * hdr)
+{
+  if (hdr->sh_flags & SHF_ARM_NOREAD)
+    * flags |= SEC_COFF_NOREAD;
+  return TRUE;
+}
+
+static flagword
+arm_elf_lookup_section_flags (char *flag_name)
+{
+  if (!strcmp (flag_name, "SHF_ARM_NOREAD"))
+    return SHF_ARM_NOREAD;
+
+  return 0;
+}
+
 #define ELF_ARCH			bfd_arch_arm
 #define ELF_TARGET_ID			ARM_ELF_DATA
 #define ELF_MACHINE_CODE		EM_ARM
@@ -16212,6 +16262,13 @@ elf32_arm_get_synthetic_symtab (bfd *abfd,
 #define elf_backend_obj_attrs_order		elf32_arm_obj_attrs_order
 #define elf_backend_obj_attrs_handle_unknown 	elf32_arm_obj_attrs_handle_unknown
 
+#undef  elf_backend_special_sections
+#define elf_backend_special_sections 		elf32_arm_special_sections
+#undef elf_backend_section_flags
+#define elf_backend_section_flags		arm_elf_section_flags
+#undef elf_backend_lookup_section_flags_hook
+#define elf_backend_lookup_section_flags_hook   arm_elf_lookup_section_flags
+
 #include "elf32-target.h"
 
 /* Native Client targets.  */
diff --git a/include/elf/arm.h b/include/elf/arm.h
index 34afdfd..c6289f6 100644
--- a/include/elf/arm.h
+++ b/include/elf/arm.h
@@ -83,6 +83,7 @@
 
 /* ARM-specific values for sh_flags.  */
 #define SHF_ENTRYSECT      0x10000000   /* Section contains an entry point.  */
+#define SHF_ARM_NOREAD     0x20000000   /* Section contains code that can be place on no read memory area.  */
 #define SHF_COMDEF         0x80000000   /* Section may be multiply defined in the input to a link step.  */
 
 /* ARM-specific program header flags.  */
-- 
2.6.2

